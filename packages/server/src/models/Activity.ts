import mongoose, { Document, Model, Schema } from 'mongoose';

import { computeActivityPrefix } from '../lib/activity/message';
import { TransformedActivitySchema } from '../validators/activity';
import { IComment } from './Comment';
import { IPublication } from './Publication';
import { IReview } from './Review';
import UserModel, { IUser, IUserDocument, IUserRole } from './User';

/**
 * The sub-system that an activity is referencing to.
 */
export enum IActivityType {
    Publication = 'publication',
    User = 'user',
    Review = 'review',
    Comment = 'comment',
}

/**
 * The general operation kind that affects the activity sub-system. For example, an
 * activity could have a type of 'Publication' and kind 'Create' which denotes that the
 * user created the publication.
 */
export enum IActivityOperationKind {
    Delete = 'delete',
    Create = 'create',
    Update = 'update',
    Revise = 'revise',
}

/** Type representing a recorded activity in the system */
export interface IActivity {
    /** The sub-system that the activity refers to */
    type: IActivityType;
    /** Generic kind representing how the activity affected the document in question */
    kind: IActivityOperationKind;
    /** The ID of the publication that this activity refers to. */
    owner: mongoose.ObjectId;
    /** The document that was affected by the operation */
    document?: mongoose.ObjectId;
    /**
     * The permission that is required to read the activity. This is automatically
     * inherited from the owner of the activity.
     * */
    permission: IUserRole;
    /**
     * Information that might be relevant to the activity (such as fields modified or
     *  a diff of two previous documents).
     * */
    metadata?: Object;
    /** If the activity was recorded and can be displayed */
    isLive: boolean;
    /** When the initial document was created */
    createdAt: Date;
    /** When the document was last updated */
    updatedAt: Date;
}

/**
 * General representation of a reference in a @see TransformedActivity. This is
 * used to transform the message into a human readable format so that it can be
 * displayed in whatever appropriate format.
 */
export type ActivityReference =
    | { type: 'user'; document: Partial<IUser> }
    | { type: 'publication'; document: Partial<IPublication> }
    | { type: 'review'; document: Partial<IReview> }
    | { type: 'comment'; document: Partial<IComment> };

/**
 * Produced representation of an activity that is generated by the projection
 * function defined on the @see ActivitySchema.
 */
interface TransformedActivity {
    message: string;
    owner: Partial<IUser>;
    createdAt: number;
    updatedAt: number;
    references: ActivityReference[];
}

export type AugmentedActivityDocument = Omit<IActivity, '_id'> & {
    _id: mongoose.Types.ObjectId;
};

export type PopulatedActivity = AugmentedActivityDocument & {
    owner: IUser;
};

interface IActivityDocument extends IActivity, Document {}

interface IActivityModel extends Model<IActivityDocument> {
    project: (activity: AugmentedActivityDocument) => Partial<TransformedActivity>;
    projectWith: (activity: AugmentedActivityDocument, user: IUser) => Partial<TransformedActivity>;
}

const ActivitySchema = new Schema<IActivity, IActivityModel, IActivity>(
    {
        type: {
            type: String,
            enum: IActivityType,
            required: true,
        },
        kind: {
            type: String,
            enum: IActivityOperationKind,
            required: true,
        },
        permission: {
            type: String,
            enum: IUserRole,
            required: true,
        },
        isLive: { type: Boolean, required: true, default: false },
        owner: { type: mongoose.Schema.Types.ObjectId, ref: 'user' },
        metadata: { type: Object },
        // We can't specifically bind it to a document because we can't deduce this until
        // we actually create the activity document
        document: { type: mongoose.Schema.Types.ObjectId },
    },
    { timestamps: true },
);

ActivitySchema.statics.project = async (
    activity: PopulatedActivity,
): Promise<TransformedActivity> => {
    let message = '<0> '; // begin the message with the prefix that user '0' did something...

    const owner = UserModel.project(activity.owner);
    const references: ActivityReference[] = [
        {
            type: 'user',
            document: owner,
        },
    ];

    const { prefixMessage, prefixReferences } = await computeActivityPrefix(activity);
    message += prefixMessage;
    references.push(...prefixReferences);

    // before we send of the request, let's validate that the number of references in the
    // generated message is correct...
    TransformedActivitySchema.parse({ message, references });

    return {
        message,
        references,
        owner,
        updatedAt: activity.updatedAt.getTime(),
        createdAt: activity.createdAt.getTime(),
    };
};

ActivitySchema.statics.projectWith = async (
    activity: AugmentedActivityDocument,
    user: IUserDocument,
): Promise<TransformedActivity> => {
    let message = '<0> '; // begin the message with the prefix that user '0' did something...

    const owner = UserModel.project(user);
    const references: ActivityReference[] = [
        {
            type: 'user',
            document: owner,
        },
    ];

    const { prefixMessage, prefixReferences } = await computeActivityPrefix(activity);
    message += `${prefixMessage}.`;
    references.push(...prefixReferences);

    // before we send of the request, let's validate that the number of references in the
    // generated message is correct...
    TransformedActivitySchema.parse({ message, references });

    return {
        message,
        references,
        owner,
        updatedAt: activity.updatedAt.getTime(),
        createdAt: activity.createdAt.getTime(),
    };
};

export default mongoose.model<IActivity, IActivityModel>('activity', ActivitySchema);
