import mongoose, { Document, Model, Schema } from 'mongoose';

import { computeActivityPrefix } from '../lib/activity/message';
import { TransformedActivitySchema } from '../validators/activity';
import { IComment } from './Comment';
import { TransformedPublication } from './Publication';
import { IReview } from './Review';
import UserModel, { IUser, IUserDocument, IUserRole, TransformedUser } from './User';

/**
 * The sub-system that an activity is referencing to.
 */
export enum IActivityType {
    Publication = 'publication',
    User = 'user',
    Review = 'review',
    Comment = 'comment',
}

/**
 * The general operation kind that affects the activity sub-system. For example, an
 * activity could have a type of 'Publication' and kind 'Create' which denotes that the
 * user created the publication.
 */
export enum IActivityOperationKind {
    Delete = 'delete',
    Create = 'create',
    Update = 'update',
    Revise = 'revise',
}

/** Type representing a recorded activity in the system */
export interface IActivity {
    /** The sub-system that the activity refers to */
    type: IActivityType;
    /** Generic kind representing how the activity affected the document in question */
    kind: IActivityOperationKind;
    /** The ID of the publication that this activity refers to. */
    owner: mongoose.Types.ObjectId;
    /** The document that was affected by the operation */
    document?: mongoose.Types.ObjectId;
    /**
     * The permission that is required to read the activity. This is automatically
     * inherited from the owner of the activity.
     * */
    permission: IUserRole;
    /**
     * Information that might be relevant to the activity (such as fields modified or
     *  a diff of two previous documents).
     * */
    metadata?: Object;
    /** If the activity was recorded and can be displayed */
    isLive: boolean;
    /** When the initial document was created */
    createdAt: Date;
    /** When the document was last updated */
    updatedAt: Date;
}

/**
 * General representation of a reference in a @see TransformedActivity. This is
 * used to transform the message into a human readable format so that it can be
 * displayed in whatever appropriate format.
 */
export type ActivityReference =
    | { type: 'user'; document: TransformedUser }
    | { type: 'publication'; document: TransformedPublication }
    | { type: 'review'; document: Partial<IReview> }
    | { type: 'comment'; document: Partial<IComment> };

/**
 * Produced representation of an activity that is generated by the projection
 * function defined on the @see ActivitySchema.
 */
interface TransformedActivity {
    id: string;
    message: string;
    owner: TransformedUser;
    createdAt: number;
    updatedAt: number;
    type: IActivityType;
    kind: IActivityOperationKind;
    references: ActivityReference[];
}

interface IActivityDocument extends IActivity, Document {}

export type AugmentedActivityDocument = Omit<IActivityDocument, '_id'> & {
    _id: mongoose.Types.ObjectId;
};

export type PopulatedActivity = AugmentedActivityDocument & {
    owner: IUser;
};

interface IActivityModel extends Model<IActivityDocument> {
    project: (activity: PopulatedActivity) => Promise<Partial<TransformedActivity>>;
    projectWith: (
        activity: AugmentedActivityDocument,
        user: IUser,
    ) => Promise<Partial<TransformedActivity>>;
}

const ActivitySchema = new Schema<IActivity, IActivityModel, IActivity>(
    {
        type: {
            type: String,
            enum: IActivityType,
            required: true,
        },
        kind: {
            type: String,
            enum: IActivityOperationKind,
            required: true,
        },
        permission: {
            type: String,
            enum: IUserRole,
            required: true,
        },
        isLive: { type: Boolean, required: true, default: false },
        owner: { type: mongoose.Schema.Types.ObjectId, ref: 'user' },
        metadata: { type: Object },
        // We can't specifically bind it to a document because we can't deduce this until
        // we actually create the activity document
        document: { type: mongoose.Schema.Types.ObjectId },
    },
    { timestamps: true },
);

ActivitySchema.statics.project = async (
    activity: PopulatedActivity,
): Promise<TransformedActivity> => {
    const { kind, type } = activity;
    const { prefixMessage, prefixReferences: references } = await computeActivityPrefix(activity);
    const message = `${prefixMessage}.`;

    // before we send of the request, let's validate that the number of references in the
    // generated message is correct...
    TransformedActivitySchema.parse({ message, references });

    return {
        id: activity._id.toString(),
        message,
        references,
        kind,
        type,
        owner: UserModel.project(activity.owner),
        updatedAt: activity.updatedAt.getTime(),
        createdAt: activity.createdAt.getTime(),
    };
};

ActivitySchema.statics.projectWith = async (
    activity: AugmentedActivityDocument,
    user: IUserDocument,
): Promise<TransformedActivity> => {
    const { kind, type } = activity;
    const { prefixMessage, prefixReferences: references } = await computeActivityPrefix(activity);
    const message = `${prefixMessage}.`;

    // before we send of the request, let's validate that the number of references in the
    // generated message is correct...
    TransformedActivitySchema.parse({ message, references });

    return {
        id: activity._id.toString(),
        message,
        references,
        kind,
        type,
        owner: UserModel.project(user),
        updatedAt: activity.updatedAt.getTime(),
        createdAt: activity.createdAt.getTime(),
    };
};

export default mongoose.model<IActivity, IActivityModel>('activity', ActivitySchema);
