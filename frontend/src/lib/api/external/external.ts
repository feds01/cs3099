/**
 * Generated by orval v6.2.3 üç∫
 * Do not edit manually.
 * Iamus API
 * This is a REST API for interfacing with Iamus. This API provides endpoints for interacting with user information, submissions, and reviews.
 * OpenAPI spec version: 1.0.0
 */
import {
  useQuery,
  useMutation,
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction
} from 'react-query'
import type {
  UserAuthResponseResponse,
  BadRequestResponse,
  UnauthorizedResponse,
  InternalServerErrorResponse,
  UserLogin,
  PostSgSsoLoginParams,
  TokenVerificationResponseResponse,
  PostSgSsoVerifyParams,
  PostSgSsoCallbackParams,
  PublicationExportResponseResponse,
  PublicationMetadataResponseResponse,
  UnprocessableEntityResponse,
  EmailValidation
} from '.././models'
import { customInstance } from '.././mutator/custom-instance'

type AsyncReturnType<
T extends (...args: any) => Promise<any>
> = T extends (...args: any) => Promise<infer R> ? R : any;


/**
 * Endpoint for external services to authenticate with this service.
 * @summary External login endpoint
 */
export const postSgSsoLogin = (
    userLogin: UserLogin,
    params?: PostSgSsoLoginParams,
 ) => {
      return customInstance<UserAuthResponseResponse>(
      {url: `/sg/sso/login`, method: 'post',
      data: userLogin,
        params,
    },
      );
    }
  


    export const usePostSgSsoLogin = <TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof postSgSsoLogin>, TError,{data: UserLogin;params?: PostSgSsoLoginParams}, TContext>, }
) => {
      const {mutation: mutationOptions} = options || {}

      const mutationFn: MutationFunction<AsyncReturnType<typeof postSgSsoLogin>, {data: UserLogin;params?: PostSgSsoLoginParams}> = (props) => {
          const {data,params} = props || {};

          return  postSgSsoLogin(data,params,)
        }

      return useMutation<AsyncReturnType<typeof postSgSsoLogin>, TError, {data: UserLogin;params?: PostSgSsoLoginParams}, TContext>(mutationFn, mutationOptions)
    }
    /**
 * Endpoint to refresh a JWT token
 * @summary Refresh user session
 */
export const postSgSsoVerify = (
    params?: PostSgSsoVerifyParams,
 ) => {
      return customInstance<TokenVerificationResponseResponse>(
      {url: `/sg/sso/verify`, method: 'post',
      data: undefined,
        params,
    },
      );
    }
  


    export const usePostSgSsoVerify = <TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof postSgSsoVerify>, TError,{params?: PostSgSsoVerifyParams}, TContext>, }
) => {
      const {mutation: mutationOptions} = options || {}

      const mutationFn: MutationFunction<AsyncReturnType<typeof postSgSsoVerify>, {params?: PostSgSsoVerifyParams}> = (props) => {
          const {params} = props || {};

          return  postSgSsoVerify(params,)
        }

      return useMutation<AsyncReturnType<typeof postSgSsoVerify>, TError, {params?: PostSgSsoVerifyParams}, TContext>(mutationFn, mutationOptions)
    }
    /**
 * This endpoint is used to notify the journal that the external login was successful and we should proceed with authenticating the external user. This might mean that there is an internal process of registering the user on the platform.
 * @summary Successful external login endpoint.
 */
export const postSgSsoCallback = (
    params?: PostSgSsoCallbackParams,
 ) => {
      return customInstance<void>(
      {url: `/sg/sso/callback`, method: 'post',
      data: undefined,
        params,
    },
      );
    }
  


    export const usePostSgSsoCallback = <TError = InternalServerErrorResponse,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof postSgSsoCallback>, TError,{params?: PostSgSsoCallbackParams}, TContext>, }
) => {
      const {mutation: mutationOptions} = options || {}

      const mutationFn: MutationFunction<AsyncReturnType<typeof postSgSsoCallback>, {params?: PostSgSsoCallbackParams}> = (props) => {
          const {params} = props || {};

          return  postSgSsoCallback(params,)
        }

      return useMutation<AsyncReturnType<typeof postSgSsoCallback>, TError, {params?: PostSgSsoCallbackParams}, TContext>(mutationFn, mutationOptions)
    }
    /**
 * @summary Endpoint to download an archive representing the publication sources.
 */
export const getSgResourcesExportId = (
    id: string,
 ) => {
      return customInstance<PublicationExportResponseResponse>(
      {url: `/sg/resources/export/${id}`, method: 'get'
    },
      );
    }
  

export const getGetSgResourcesExportIdQueryKey = (id: string,) => [`/sg/resources/export/${id}`];

    
export const useGetSgResourcesExportId = <TData = AsyncReturnType<typeof getSgResourcesExportId>, TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse>(
 id: string, options?: { query?:UseQueryOptions<AsyncReturnType<typeof getSgResourcesExportId>, TError, TData>, }

  ) => {

  const {query: queryOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getGetSgResourcesExportIdQueryKey(id);
  const queryFn: QueryFunction<AsyncReturnType<typeof getSgResourcesExportId>> = () => getSgResourcesExportId(id, );

  const query = useQuery<AsyncReturnType<typeof getSgResourcesExportId>, TError, TData>(queryKey, queryFn, {enabled: !!(id), ...queryOptions})

  return {
    queryKey,
    ...query
  }
}

/**
 * @summary Endpoint to download the publication metadata
 */
export const getSgResourcesExportIdMetadata = (
    id: string,
 ) => {
      return customInstance<PublicationMetadataResponseResponse>(
      {url: `/sg/resources/export/${id}/metadata`, method: 'get'
    },
      );
    }
  

export const getGetSgResourcesExportIdMetadataQueryKey = (id: string,) => [`/sg/resources/export/${id}/metadata`];

    
export const useGetSgResourcesExportIdMetadata = <TData = AsyncReturnType<typeof getSgResourcesExportIdMetadata>, TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse>(
 id: string, options?: { query?:UseQueryOptions<AsyncReturnType<typeof getSgResourcesExportIdMetadata>, TError, TData>, }

  ) => {

  const {query: queryOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getGetSgResourcesExportIdMetadataQueryKey(id);
  const queryFn: QueryFunction<AsyncReturnType<typeof getSgResourcesExportIdMetadata>> = () => getSgResourcesExportIdMetadata(id, );

  const query = useQuery<AsyncReturnType<typeof getSgResourcesExportIdMetadata>, TError, TData>(queryKey, queryFn, {enabled: !!(id), ...queryOptions})

  return {
    queryKey,
    ...query
  }
}

/**
 * Check if an email is valid to use when registering
 * @summary Pre-registration email validation
 */
export const postAuthEmailvalidation = (
    emailValidation: EmailValidation,
 ) => {
      return customInstance<void>(
      {url: `/auth/email_validation`, method: 'post',
      data: emailValidation
    },
      );
    }
  


    export const usePostAuthEmailvalidation = <TError = UnprocessableEntityResponse | InternalServerErrorResponse,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof postAuthEmailvalidation>, TError,{data: EmailValidation}, TContext>, }
) => {
      const {mutation: mutationOptions} = options || {}

      const mutationFn: MutationFunction<AsyncReturnType<typeof postAuthEmailvalidation>, {data: EmailValidation}> = (props) => {
          const {data} = props || {};

          return  postAuthEmailvalidation(data,)
        }

      return useMutation<AsyncReturnType<typeof postAuthEmailvalidation>, TError, {data: EmailValidation}, TContext>(mutationFn, mutationOptions)
    }
    