/**
 * Generated by orval v6.2.3 üç∫
 * Do not edit manually.
 * Iamus API
 * This is a REST API for interfacing with Iamus. This API provides endpoints for interacting with user information, submissions, and reviews.
 * OpenAPI spec version: 1.0.0
 */
import {
  useQuery,
  useMutation,
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction
} from 'react-query'
import type {
  UserAuthResponseResponse,
  BadRequestResponse,
  UnauthorizedResponse,
  InternalServerErrorResponse,
  UserLogin,
  GetSgSsoLoginParams,
  TokenVerificationResponseResponse,
  GetSgSsoVerifyParams,
  GetSgSsoCallbackParams,
  PublicationExportResponseResponse,
  PublicationMetadataResponseResponse,
  UnprocessableEntityResponse,
  EmailValidation
} from '.././models'
import { customInstance } from '.././mutator/custom-instance'

type AsyncReturnType<
T extends (...args: any) => Promise<any>
> = T extends (...args: any) => Promise<infer R> ? R : any;


/**
 * Endpoint for external services to authenticate with this service.
 * @summary External login endpoint
 */
export const getSgSsoLogin = (
    userLogin: UserLogin,
    params?: GetSgSsoLoginParams,
 ) => {
      return customInstance<UserAuthResponseResponse>(
      {url: `/sg/sso/login`, method: 'get',
        params,
    },
      );
    }
  

export const getGetSgSsoLoginQueryKey = (userLogin: UserLogin,
    params?: GetSgSsoLoginParams,) => [`/sg/sso/login`, ...(params ? [params]: []), userLogin];

    
export const useGetSgSsoLogin = <TData = AsyncReturnType<typeof getSgSsoLogin>, TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse>(
 userLogin: UserLogin,
    params?: GetSgSsoLoginParams, options?: { query?:UseQueryOptions<AsyncReturnType<typeof getSgSsoLogin>, TError, TData>, }

  ) => {

  const {query: queryOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getGetSgSsoLoginQueryKey(userLogin,params);
  const queryFn: QueryFunction<AsyncReturnType<typeof getSgSsoLogin>> = () => getSgSsoLogin(userLogin,params, );

  const query = useQuery<AsyncReturnType<typeof getSgSsoLogin>, TError, TData>(queryKey, queryFn, queryOptions)

  return {
    queryKey,
    ...query
  }
}

/**
 * Endpoint to refresh a JWT token
 * @summary Refresh user session
 */
export const getSgSsoVerify = (
    params?: GetSgSsoVerifyParams,
 ) => {
      return customInstance<TokenVerificationResponseResponse>(
      {url: `/sg/sso/verify`, method: 'get',
        params,
    },
      );
    }
  

export const getGetSgSsoVerifyQueryKey = (params?: GetSgSsoVerifyParams,) => [`/sg/sso/verify`, ...(params ? [params]: [])];

    
export const useGetSgSsoVerify = <TData = AsyncReturnType<typeof getSgSsoVerify>, TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse>(
 params?: GetSgSsoVerifyParams, options?: { query?:UseQueryOptions<AsyncReturnType<typeof getSgSsoVerify>, TError, TData>, }

  ) => {

  const {query: queryOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getGetSgSsoVerifyQueryKey(params);
  const queryFn: QueryFunction<AsyncReturnType<typeof getSgSsoVerify>> = () => getSgSsoVerify(params, );

  const query = useQuery<AsyncReturnType<typeof getSgSsoVerify>, TError, TData>(queryKey, queryFn, queryOptions)

  return {
    queryKey,
    ...query
  }
}

/**
 * This endpoint is used to notify the journal that the external login was successful and we should proceed with authenticating the external user. This might mean that there is an internal process of registering the user on the platform.
 * @summary Successful external login endpoint.
 */
export const getSgSsoCallback = (
    params?: GetSgSsoCallbackParams,
 ) => {
      return customInstance<void>(
      {url: `/sg/sso/callback`, method: 'get',
        params,
    },
      );
    }
  

export const getGetSgSsoCallbackQueryKey = (params?: GetSgSsoCallbackParams,) => [`/sg/sso/callback`, ...(params ? [params]: [])];

    
export const useGetSgSsoCallback = <TData = AsyncReturnType<typeof getSgSsoCallback>, TError = InternalServerErrorResponse>(
 params?: GetSgSsoCallbackParams, options?: { query?:UseQueryOptions<AsyncReturnType<typeof getSgSsoCallback>, TError, TData>, }

  ) => {

  const {query: queryOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getGetSgSsoCallbackQueryKey(params);
  const queryFn: QueryFunction<AsyncReturnType<typeof getSgSsoCallback>> = () => getSgSsoCallback(params, );

  const query = useQuery<AsyncReturnType<typeof getSgSsoCallback>, TError, TData>(queryKey, queryFn, queryOptions)

  return {
    queryKey,
    ...query
  }
}

/**
 * @summary Endpoint to download an archive representing the publication sources.
 */
export const getSgResourcesExportId = (
    id: string,
 ) => {
      return customInstance<PublicationExportResponseResponse>(
      {url: `/sg/resources/export/${id}`, method: 'get'
    },
      );
    }
  

export const getGetSgResourcesExportIdQueryKey = (id: string,) => [`/sg/resources/export/${id}`];

    
export const useGetSgResourcesExportId = <TData = AsyncReturnType<typeof getSgResourcesExportId>, TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse>(
 id: string, options?: { query?:UseQueryOptions<AsyncReturnType<typeof getSgResourcesExportId>, TError, TData>, }

  ) => {

  const {query: queryOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getGetSgResourcesExportIdQueryKey(id);
  const queryFn: QueryFunction<AsyncReturnType<typeof getSgResourcesExportId>> = () => getSgResourcesExportId(id, );

  const query = useQuery<AsyncReturnType<typeof getSgResourcesExportId>, TError, TData>(queryKey, queryFn, {enabled: !!(id), ...queryOptions})

  return {
    queryKey,
    ...query
  }
}

/**
 * @summary Endpoint to download the publication metadata
 */
export const getSgResourcesExportIdMetadata = (
    id: string,
 ) => {
      return customInstance<PublicationMetadataResponseResponse>(
      {url: `/sg/resources/export/${id}/metadata`, method: 'get'
    },
      );
    }
  

export const getGetSgResourcesExportIdMetadataQueryKey = (id: string,) => [`/sg/resources/export/${id}/metadata`];

    
export const useGetSgResourcesExportIdMetadata = <TData = AsyncReturnType<typeof getSgResourcesExportIdMetadata>, TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse>(
 id: string, options?: { query?:UseQueryOptions<AsyncReturnType<typeof getSgResourcesExportIdMetadata>, TError, TData>, }

  ) => {

  const {query: queryOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getGetSgResourcesExportIdMetadataQueryKey(id);
  const queryFn: QueryFunction<AsyncReturnType<typeof getSgResourcesExportIdMetadata>> = () => getSgResourcesExportIdMetadata(id, );

  const query = useQuery<AsyncReturnType<typeof getSgResourcesExportIdMetadata>, TError, TData>(queryKey, queryFn, {enabled: !!(id), ...queryOptions})

  return {
    queryKey,
    ...query
  }
}

/**
 * Check if an email is valid to use when registering
 * @summary Pre-registration email validation
 */
export const postAuthEmailvalidation = (
    emailValidation: EmailValidation,
 ) => {
      return customInstance<void>(
      {url: `/auth/email_validation`, method: 'post',
      data: emailValidation
    },
      );
    }
  


    export const usePostAuthEmailvalidation = <TError = UnprocessableEntityResponse | InternalServerErrorResponse,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof postAuthEmailvalidation>, TError,{data: EmailValidation}, TContext>, }
) => {
      const {mutation: mutationOptions} = options || {}

      const mutationFn: MutationFunction<AsyncReturnType<typeof postAuthEmailvalidation>, {data: EmailValidation}> = (props) => {
          const {data} = props || {};

          return  postAuthEmailvalidation(data,)
        }

      return useMutation<AsyncReturnType<typeof postAuthEmailvalidation>, TError, {data: EmailValidation}, TContext>(mutationFn, mutationOptions)
    }
    